package persistence;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.LinkedList;
import java.util.List;

import model.Adresse;
import model.Nutzer;
import model.Status;
import util.exception.DuplicateEntryException;
import util.exception.ValidateArgsException;

/**
 * @author domin
 *
 */
public class NutzerDAO {
	private DataSource datasource = DataSource.getInstance();

	private final String TABLE = "nutzer";
	
	/**
	 * @param nutzer
	 * @return the generated ID of the new {@link model.Nutzer}
	 * @throws DuplicateEntryException
	 * @throws SQLException
	 */
	public int addNutzer(final Nutzer nutzer) throws DuplicateEntryException, SQLException {
		// get address from nutzer
		final Adresse address = nutzer.getAddress();
		int nid = -1;

		// check if a Nutzer with this eMail-address is already existing
		if (getNutzer(nutzer.geteMail()) != null) {
			throw new DuplicateEntryException("E-Mail wird schon verwendet!");
		}

		// try with connection
		try (Connection connect = datasource.getConnection()) {
			// set the sql query
			String sql = "INSERT INTO Nutzer values (default, ?, ?, ?, ? , ?, ?, ?, ?, ?, ?, ?)";
			// try with statement
			try (PreparedStatement preparedStatement = connect.prepareStatement(sql)) {
				// set params
				preparedStatement.setString(1, nutzer.getFirstName());
				preparedStatement.setString(2, nutzer.getLastName());
				// fetch the sex id
				int sexId = new SexDAO().getSex(nutzer.getSex());
				preparedStatement.setInt(3, sexId);
				preparedStatement.setObject(4, nutzer.getBirthdate());
				preparedStatement.setString(5, nutzer.geteMail());
				preparedStatement.setString(6, nutzer.getPassword());
				preparedStatement.setString(7, address.getPlz());
				preparedStatement.setString(8, address.getCity());
				preparedStatement.setString(9, address.getStreet());
				preparedStatement.setString(10, address.getNumber());
				preparedStatement.setString(11, nutzer.getStatus().getText());

				preparedStatement.executeUpdate();
			}

			// fetch the id generated by database
			sql = "SELECT LAST_INSERT_ID()";
			try (PreparedStatement preparedStatement = connect.prepareStatement(sql)) {
				try (ResultSet resultSet = preparedStatement.executeQuery()) {
					while (resultSet.next()) {
						nid = resultSet.getInt("last_insert_id()");
					}
				}
			}
		}
		return nid;
	}

	/**
	 * processes fetched data from database to a {@link model.Nutzer Nutzer}
	 * 
	 * @param resultSet
	 * @return
	 * @throws SQLException
	 */
	private List<Nutzer> getNutzerFromResultSet(final ResultSet resultSet) throws SQLException {
		final List<Nutzer> result = new LinkedList<>();
		// for each row returned from database
		while (resultSet.next()) {
			// get values from resultset
			final int nutzerId = resultSet.getInt("NID");
			final String firstName = resultSet.getString("firstName");
			final String lastName = resultSet.getString("lastName");
			final int sexId = resultSet.getInt("sexId");
			final String sex = new SexDAO().getSex(sexId);
			final Date birthdateSQL = resultSet.getDate("birthdate");
			final LocalDate birthdate = birthdateSQL.toLocalDate();
			final String eMail = resultSet.getString("eMail");
			final String password = resultSet.getString("password");
			final String plz = resultSet.getString("plz");
			final String city = resultSet.getString("city");
			final String street = resultSet.getString("street");
			final String number = resultSet.getString("number");
			final String status = resultSet.getString("status");
			try {
				// store fetched data in Nutzer-Object
				final Nutzer tempNutzer = new Nutzer(nutzerId, firstName, lastName, sex, birthdate, eMail, password,
						new Adresse(plz, city, street, number), Status.valueOf(status));
				result.add(tempNutzer);

			} catch (final ValidateArgsException e) {
				throw new SQLException("Datenbank ist inkonsistent!", e);
			}
		}
		return result;
	}

	/**
	 * @param eMail
	 * @return a {@link model.Nutzer} with given ID
	 * @throws SQLException
	 */
	public Nutzer getNutzer(final String eMail) throws SQLException {
		SelectSql statement = new SelectSql();

		String columns = "*";
		String condition = "eMail=?";
		List<Object> conditionWildcards = new LinkedList<>();
		conditionWildcards.add(eMail);

		statement.select(columns).from(TABLE).where(conditionWildcards, condition);
		ResultSet result = statement.executeQuery();

		return getNutzerFromResultSet(result).get(0);
	}

	/**
	 * @param id
	 * @return a {@link model.Nutzer} with given eMail
	 * @throws SQLException
	 */
	public Nutzer getNutzer(final int id) throws SQLException {
		SelectSql statement = new SelectSql();

		String columns = "*";
		String condition = "NID=?";
		List<Object> conditionWildcards = new LinkedList<>();
		conditionWildcards.add(id);

		statement.select(columns).from(TABLE).where(conditionWildcards, condition);
		ResultSet result = statement.executeQuery();

		return getNutzerFromResultSet(result).get(0);
	}

	/**
	 * @return a List of all {@link model.Nutzer Nutzer} in database
	 * @throws SQLException
	 */
	public List<Nutzer> getAllNutzer() throws SQLException {
		SelectSql statement = new SelectSql();

		String columns = "*";
		
		statement.select(columns).from(TABLE);
		ResultSet result = statement.executeQuery();

		return getNutzerFromResultSet(result);
	}

	/**
	 * @param nutzer
	 * @throws SQLException
	 */
	public void changeNutzer(Nutzer nutzer) throws SQLException {
		// get address from nutzer
		final Adresse address = nutzer.getAddress();
		String sql = "UPDATE Nutzer SET eMail = ?, password = ?, firstName = ?, lastName = ?, sexId = ?, birthdate = ?, "
				+ "plz = ?, city = ?, street = ?, number = ?, status = ? WHERE NID = ?";

		// change existing nutzer
		try (Connection connect = datasource.getConnection();
				PreparedStatement preparedStatement = connect.prepareStatement(sql)) {
			preparedStatement.setString(1, nutzer.geteMail());
			preparedStatement.setString(2, nutzer.getPassword());
			preparedStatement.setString(3, nutzer.getFirstName());
			preparedStatement.setString(4, nutzer.getLastName());
			int sexId = new SexDAO().getSex(nutzer.getSex());
			preparedStatement.setInt(5, sexId);
			preparedStatement.setObject(6, nutzer.getBirthdate());
			preparedStatement.setString(7, address.getPlz());
			preparedStatement.setString(8, address.getCity());
			preparedStatement.setString(9, address.getStreet());
			preparedStatement.setString(10, address.getNumber());
			preparedStatement.setString(11, nutzer.getStatus().getText());
			preparedStatement.setInt(12, nutzer.getNID());

			preparedStatement.executeUpdate();
		}
	}

	/**
	 * @param nid
	 * @throws SQLException
	 */
	public void deleteNutzer(final int nid) throws SQLException {
		// set the sql query
		String sql = "DELETE FROM Nutzer WHERE NID = ?";

		// try with connection and prepared statement
		try (Connection connect = datasource.getConnection();
				PreparedStatement preparedStatement = connect.prepareStatement(sql)) {
			// set param
			preparedStatement.setInt(1, nid);

			preparedStatement.executeUpdate();
		}
	}
}
